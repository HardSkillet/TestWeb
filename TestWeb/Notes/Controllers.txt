Конктроллеры

		Контроллеры и их действия
	1. В ASP.NET Core MVC контроллер представляет обычный класс на языке C#, который наследуется от абстрактного базового класса Microsoft.AspNetCore.Mvc.Controller
	2. При использовании контроллеров существуют некоторые условности: 
		Во-первых, в проекте контроллеры помещаются в каталог Controllers 
		Во-вторых, по соглашениям об именовании названия контроллеров обычно оканчиваются на суффикс "Controller", 
			остальная же часть до этого суффикса считается именем контроллера, например, HomeController 
		Но в принципе эти условности необязательны
	3. Но есть также и обязательные условности, которые предъявляются к контроллерам. В частности, 
		класс контроллера должен удовлетворять как минимум одному из следующих условий:	
			а. Класс контроллера имеет суффикс "Controller"
			б. Класс контроллера наследуется от класса, который имеет суффикс "Controller"
			в. К классу контроллера применяется атрибут [Controller]
	4. Контроллер, как и любой класс на языке C#, может иметь поля, свойства, методы
	5. Чтобы обратиться контроллеру из веб-браузера, нам надо в адресной строке набрать адрес_сайта/Имя_контроллера/Действие_контроллера
	6. Однако такое сопоставление строки url с названием контроллера и его метода происходит благодаря системе маршрутизации
	7. Метод endpoints.MapControllerRoute добавляет один маршрут с именем default и шаблоном "{controller=Home}/{action=Index}/{id?}"
		Данный шаблон устанавливает трехсегментную структуру строки запроса: controller/action/id. 
		То есть в начале идет название контроллера, затем название действия, и далее может идти необязательный параметр id
	8. Чтобы указать, что этот класс не является контроллером, нам надо использовать над ним атрибут [NonController]
	9. Аналогично, если мы хотим, чтобы какой-либо публичный метод контроллера не рассматривался как действие, то мы можем использовать над ним атрибут NonAction
	10. Атрибут [ActionName] позволяет для метода задать другое имя действия
	11. Кроме того, методы в рамках одного действия могут обслуживать разные запросы. 
		Для указания типа запроса HTTP нам надо применить к методу один из атрибутов: [HttpGet], [HttpPost], [HttpPut], [HttpDelete] и [HttpHead]
	12. Если атрибут явным образом не указан, то метод может обрабатывать все типы запросов: GET, POST, PUT, DELETE

		Передача данных в контроллер
	1. Чтобы передать значение для параметра id, нам надо отправить запрос типа http://localhost:57086/Home/Hello?id=9
	2. Если метод принимает несколько параметров, в этом случае мы можем обратиться к действию, набрав в адресной строке Home/Square?a=10&h=3
	3. В случае передачи сложных параметров, параметры строки запроса должны соответствовать по имени свойствам объекта. Регистр названий при этом не учитывается
	4. Чтобы передать значения для массива, нам надо использовалась строку запроса наподобие http://localhost:57086/Home/Sum?nums=1&nums=2&nums=3. 
		В этом случае в массиве nums окажется три элемента
	5. Чтобы передать значения для массива, нам надо использовалась строку запроса наподобие http://localhost:57086/Home/Sum?nums=1&nums=2&nums=3. 
		В этом случае в массиве nums окажется три элемента	
	6. Параметры представляют самый простой способ получения данных, но в действительности нам необязательно их использовать. 
		В контроллере доступен объект Request, у которого можно получить как данные строки запроса, так и данные отправленных форм

		Результаты действий
	1. Результатом действия может быть какой-нибудь сложный объект или может быть даже void
	2. В большинстве случаев мы будем иметь дело не с void и даже не с типом string, а с объектами типа IActionResult, 
		которые непосредственно предназначены для генерации результата действия
	3. Интерфейс IActionResult определяет один метод: 
		Task ExecuteResultAsync(ActionContext context);
	4. Eсли мы вдруг захотим создать свой класс результата действий, то как раз можем либо унаследовать его от ActionResult, либо реализовать интерфейс IActionResult
	5. Однако в большинстве случаев нам не придется создавать свои классы результатов, потому что фреймворк ASP.NET MVC Core 
		итак предоставляет довольно большое количество классов результатов для самых различных ситуаций:
			а. ContentResult: пишет указанный контент напрямую в ответ в виде строки
			б. EmptyResult: отправляет пустой ответ в виде статусного кода 200
			в. NoContentResult: во многом похож на EmptyResult, также отправляет пустой ответ, только в виде статусного кода 204
			г. FileResult: является базовым классом для всех объектов, которые пишут набор байтов в выходной поток. Предназначен для отправки файлов
			д. FileContentResult: класс, производный от FileResult, пишет в ответ массив байтов
			е. VirtualFileResult: также производный от FileResult класс, пишет в ответ файл, находящийся по заданному пути
			ж. PhysicalFileResult: также производный от FileResult класс, пишет в ответ файл, находящийся по заданному пути. 
				Только в отличие от предыдущего класса использует физический путь, а не виртуальный
			з. FileStreamResult: класс, производный от FileResult, пишет бинарный поток в выходной ответ
			и. ObjectResult: возвращает произвольный объект, как правило, применяется в качестве базового класса для других классов результатов, но можно применять и самостоятельно
			к. StatusCodeResult: результат действия, который возвращает клиенту определенный статусный код HTTP
			л. UnauthorizedResult: класс, производный от StatusCodeResult. Возвращает клиенту ответ в виде статусного кода HTTP 401, 
				указывая, что пользователь не прошел авторизацию и не имеет прав доступа к запрошенному ресурсу.
			м. NotFoundResult: производный от StatusCodeResult. Возвращает клиенту ответ в виде статусного кода HTTP 404, указывая, что запрошенный ресурс не найден
			н. NotFoundObjectResult: производный от ObjectResult. Также возвращает клиенту ответ в виде статусного кода HTTP 404 с дополнительной информацией
			о. BadRequestResult: производный от StatusCodeResult. Возвращает статусный код 400, тем самым указывая, что запрос некорректен
			п. BadRequestObjectResult: производный от ObjectResult. Возвращает статусный код 400 с некоторой дополнительной информацией
			р. OkResult: производный от StatusCodeResult. Возвращает статусный код 200, который уведомляет об успешном выполнении запроса
			с. OkObjectResult: производный от ObjectResult. Возвращает статусный код 200 с некоторой дополнительной информацией
			т. CreatedResult: возвращает статусный код 201, который уведомляет о создании нового ресурса. В качестве параметра принимает адрес нового ресурса
			у. CreatedAtActionResult: возвращает статусный код 201, который уведомляет о создании нового ресурса. 
				В качестве параметра принимает название метода и контроллера, а также параметров запроса, которые вместе создают адрес нового ресурса
			ф. CreatedAtRouteResult: возвращает статусный код 201, который уведомляет о создании нового ресурса. 
				В качестве параметра принимает название маршрута, который используется для создания адреса нового ресурса
			х. AcceptedResult: возвращает статусный код 202
			ц. AcceptedAtActionResult: возвращает статусный код 202. В качестве параметра принимает название метода и контроллера, а также параметров запроса
			ч. AcceptedAtRouteResult: возвращает статусный код 202. В качестве параметра принимает название и параметры маршрута
			ш. ChallengeResult: используется для проверки аутентификации пользователя
			щ. JsonResult: возвращает в качестве ответа объект или набор объектов в формате JSON
			э. PartialViewResult: производит рендеринг частичного представления в выходной поток
			ю. RedirectResult: перенаправляет пользователя по другому адресу URL, возвращая статусный код 302 для временной переадресации или код 301 
				для постоянной переадресации зависимости от того, установлен ли флаг Permanent.
			я. RedirectToRouteResult: класс работает подобно RedirectResult, но перенаправляет пользователя по определенному адресу URL, указанному через параметры маршрута
			аа. RedirectToActionResult: выполняет переадресацию на определенный метод контроллера
			аб. RedirectToPageResult: выполняет переадресацию на определенную странцу Razor (относится к подсистеме RazorPages)
			ав. LocalRedirectResult: перенаправляет пользователя по определенному адресу URL в рамках веб-приложения
			аг. ViewComponentResult: возвращает в ответ сущность ViewComponent
			ад. ViewResult: производит рендеринг представления и отправляет результаты рендеринга в виде html-страницы клиенту
		
		Переадресация
	1. В ASP.NET Core MVC для создания переадресации используются классы RedirectResult, LocalRedirectResult, RedirectToActionResult и RedirectToRouteResult. 
		Но в зависимости от типа переадресации их применение будет отличаться
	2. Протокол HTTP поддерживает два типа переадресации:
		а. постоянная переадресация
			При постоянной переадресации сервер будет отправлять браузеру статусный код 301. 
			При данном типе переадресации предполагается, что запрашиваемый документ окончательно перемещен в другое место. 
			И после получения статусного кода 301 браузер может автоматически настраивать запросы на новый ресурс, даже если старый ресурс со 
			временем перестанет применять переадресацию. Поэтому данный способ можно использовать, 
			если вы полностью уверены, что документ на старое место уже не возвратится..
		б. временная переадресация
			При временной переадресации сервер будет отправлять браузеру статусный код 302. 
			При этом считается, что запрашиваемый документ временно перемещен на другую страницу
	3. В обоих случаях для создания переадресации может использоваться объект RedirectResult, однако метод, возвращающий данный объект, будет отличаться:
		а. Для временной переадресации применяется метод Redirect. Также можно обращаться к внешнему ресурсу: return Redirect("http://microsoft.com")
		б. Для постоянной переадресации подобным образом используется метод RedirectPermanent
	4. Для обращения к локальным адресам в нашей системе мы можем использовать класс LocalRedirectResult 
		а. Для создания временной переадресации применяется метод LocalRedirect()
		б. Для создания постоянной переадресации - метод LocalRedirectPermanent
	5. Для создания переадресации на определенный метод контроллера используется объект RedirectToActionResult.
		Опять же для его генерации используется пара методов для временной и постоянной переадресации: RedirectToAction и RedirectToActionPermanent
	6. И последний класс, который используется для создания переадресации - RedirectToRouteResult. Для переадресации он использует маршруты. 
		Для создания объекта этого класса имеются два метода: RedirectToRoute и RedirectToRoutePermanent

